// Generated by CoffeeScript 2.7.0
//###########################################################
var NAV_info, backNavPromiseResolve, backNavPromiseTimestamp, checkCodeBackNavAction, clearNavTree, createBackNavPromise, debugFrame, debugMode, displayState, getBackNavAction, getBrowserNavAction, getNavAction, historyStateChanged, isValidHistoryState, loadAppWithNavState, navReplace, navState, navigateBack, navigateTo, navigationLocked, navstatedisplay, pageloadAction, resolveCodeBackNav, rootState, storeNavInfo, updateAppWithNavState, updateNavState;

pageloadAction = {
  action: "pageload",
  timestamp: Date.now()
};

//###########################################################
NAV_info = {
  lastNavAction: pageloadAction
};

//###########################################################
navState = {};

//###########################################################
rootState = {
  base: "RootState",
  modifier: "none",
  context: null,
  depth: 0,
  navAction: null
};

//###########################################################
backNavPromiseResolve = null;

backNavPromiseTimestamp = null;

navigationLocked = true;

loadAppWithNavState = function() {};

updateAppWithNavState = function() {};

//###########################################################
debugFrame = `<div id="NAVDEBUG-navstate-container" style="
    position: absolute;
    z-index: 9999;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    padding: 5px;
    height: fit-content;
    width: fit-content;
    box-sizing: border-box;
    color: #000;
    text-align: left;
    background-color: #fffa;
    border: solid 2px blue;
    font-size: 12px;
">
    <h1 style="
        font-size: 14px;
        font-weight: bold;
        padding: 0;
        margin: 0;
    ">NavState:</h1>
    <div id="NAVDEBUG-navstatedisplay" style="
        white-space: pre-wrap;
        line-height: 130%;
    "></div>
</div>`;

debugMode = false;

navstatedisplay = null;

//###########################################################
export var initialize = function(onLoad, onUpdate, debug) {
  var info;
  if (typeof onLoad === "function") {
    loadAppWithNavState = onLoad;
  }
  if (typeof onUpdate === "function") {
    updateAppWithNavState = onUpdate;
  }
  window.addEventListener("popstate", historyStateChanged);
  info = sessionStorage.getItem("NAV_info");
  if (info == null) {
    storeNavInfo(NAV_info);
  }
  NAV_info = JSON.parse(sessionStorage.getItem("NAV_info"));
  navigationLocked = false;
  if (debug) {
    debugMode = true;
    document.body.insertAdjacentHTML('beforeend', debugFrame);
    navstatedisplay = document.getElementById("NAVDEBUG-navstatedisplay");
  }
};

//###########################################################
export var appLoaded = async function() {
  if (navigationLocked) {
    return;
  }
  if (!isValidHistoryState()) {
    
    //# This is the very first appload    
    rootState.navAction = pageloadAction;
    NAV_info.lastNavAction = rootState.navAction;
    storeNavInfo(NAV_info);
    history.replaceState(rootState, "");
  } else {
    //# we must've done some kind of refresh
    navState = history.state;
    navState.navAction = getBrowserNavAction();
    NAV_info.lastNavAction = navState.navAction;
    storeNavInfo(NAV_info);
    history.replaceState(navState, "");
  }
  if (navState.base === "INVALID") {
    try {
      navigationLocked = true;
      await navigateBack(1);
    } finally {
      navigationLocked = false;
    }
  }
  navState = history.state;
  displayState(navState);
  loadAppWithNavState(navState);
};

//###########################################################
historyStateChanged = function(evnt) {
  var isCodeBackNav;
  if (!isValidHistoryState()) {
    throw new Error("No Valid History State on popstateEvent!"); //# What to do with this? treat it as pageLoad event?
  }
  navState = history.state;
  isCodeBackNav = checkCodeBackNavAction(NAV_info.lastNavAction);
  if (isCodeBackNav) {
    navState.navAction = NAV_info.lastNavAction;
  } else {
    navState.navAction = getBrowserNavAction();
  }
  history.replaceState(navState, "");
  displayState(navState);
  if (isCodeBackNav) {
    resolveCodeBackNav();
  } else if (navState.base !== "INVALID") {
    updateAppWithNavState(navState);
  }
};

//###########################################################
//region Helper Functions

//###########################################################
updateNavState = function(base, modifier, context, navAction) {
  navState.base = base;
  navState.modifier = modifier;
  navState.context = context || null;
  navState.navAction = navAction;
};

//###########################################################
//region Navigation Methods
navigateTo = function(base, modifier, context) {
  var navAction;
  navAction = getNavAction();
  updateNavState(base, modifier, context, navAction);
  navState.depth = navState.depth + 1;
  NAV_info.lastNavAction = navAction;
  storeNavInfo(NAV_info);
  history.pushState(navState, "");
  displayState(navState);
};

navReplace = function(base, modifier, context) {
  var navAction;
  navAction = getNavAction();
  updateNavState(base, modifier, context, navAction);
  NAV_info.lastNavAction = navAction;
  storeNavInfo(NAV_info);
  history.replaceState(navState, "");
  displayState(navState);
};

navigateBack = function(steps) {
  var backNavPromise, navAction;
  if (backNavPromiseResolve != null) {
    return;
  }
  if (navState.depth === 0 || steps > navState.depth) {
    return;
  }
  navAction = getBackNavAction();
  NAV_info.lastNavAction = navAction;
  storeNavInfo(NAV_info);
  backNavPromise = createBackNavPromise(navAction);
  //# Back navigation sets "navState" by popstate event
  history.go(-steps);
  return backNavPromise;
};

//###########################################################
clearNavTree = async function() {
  await navigateBack(navState.depth);
  navigateTo("INVALID", "none");
  await navigateBack(1);
};

//endregion

//###########################################################
//region Backwards Navigation Helpers
checkCodeBackNavAction = function(navAction) {
  if (navAction.action !== "back") {
    return false;
  }
  if (navAction.timestamp !== backNavPromiseTimestamp) {
    return false;
  }
  return true;
};

createBackNavPromise = function(navAction) {
  var pConstruct;
  backNavPromiseTimestamp = navAction.timestamp;
  pConstruct = function(resolve) {
    return backNavPromiseResolve = resolve;
  };
  return new Promise(pConstruct);
};

resolveCodeBackNav = function() {
  backNavPromiseResolve();
  backNavPromiseResolve = null;
  backNavPromiseTimestamp = null;
};

//endregion

//###########################################################
//region NavAction Objects
getBrowserNavAction = function() {
  return {
    action: "browserNav {refresh, back or forward}",
    timestamp: Date.now()
  };
};

getNavAction = function() {
  return {
    action: "nav",
    timestamp: Date.now()
  };
};

getBackNavAction = function() {
  return {
    action: "back",
    timestamp: Date.now()
  };
};

//endregion

//###########################################################
isValidHistoryState = function() {
  var hKey, historyKeys, i, idx, len, rootKeys;
  if (history.state == null) {
    return false;
  }
  historyKeys = Object.keys(history.state);
  rootKeys = Object.keys(rootState);
  if (historyKeys.length !== rootKeys.length) {
    return false;
  }
  for (idx = i = 0, len = historyKeys.length; i < len; idx = ++i) {
    hKey = historyKeys[idx];
    if (hKey !== rootKeys[idx]) {
      return false;
    }
  }
  return true;
};

//###########################################################
storeNavInfo = function(info) {
  return sessionStorage.setItem("NAV_info", JSON.stringify(info));
};

//###########################################################
displayState = function(state) {
  var stateString;
  if (navstatedisplay == null) {
    return;
  }
  stateString = JSON.stringify(state, null, 4);
  navstatedisplay.innerHTML = stateString;
};

//endregion

//###########################################################
//region Public Navigation Functions
export var toMod = async function(newMod, context) {
  var oldMod;
  if (navigationLocked) {
    return;
  }
  if (newMod == null) {
    newMod = "none";
  }
  if (typeof newMod !== "string") {
    throw new Error("In navhandler.toMod `newMod` is not a string!");
  }
  oldMod = navState.modifier;
  //# We need to merge the context, as the baseState context is still important
  if (typeof context === "object") {
    Object.assign(context, navState.context);
  } else {
    context = navState.context;
  }
  //# case 0 - oldMod is newMod 
  if (oldMod === newMod) {
    return;
  }
  //# case 1 - oldMod is "none" newMod is not "none"
  //# Nothing to be done :-)
  //# Maybe merge ne context?
  if (oldMod === "none" && newMod !== "none") {
    //# regular state navigation to state with the modifier
    navigateTo(navState.base, newMod, context);
    updateAppWithNavState(navState);
    return;
  }
  //# case 2 - oldMod is not "none" newMod is "none"
  if (oldMod !== "none" && newMod === "none") {
    try {
      //# navigate back 1 step
      navigationLocked = true;
      await navigateBack(1);
    } finally {
      navigationLocked = false;
    }
    updateAppWithNavState(navState);
    return;
  }
  //# case 3 - oldMod is not "none" newMod is different
  if (oldMod !== "none") {
    //# replace state with new State
    navReplace(navState.base, newMod, context);
    updateAppWithNavState(navState);
    return;
  }
};

export var toBase = async function(newBase, context) {
  var oldBase, oldMod;
  if (navigationLocked) {
    return;
  }
  oldBase = navState.base;
  oldMod = navState.modifier;
  if (typeof newBase !== "string") {
    throw new Error("In navhandler.toBase `newBase` must a string!");
  }
  //# If we are in INVALID state then we go back one first.
  if (oldBase === "INVALID") {
    try {
      navigationLocked = true;
      await navigateBack(1);
    } finally {
      navigationLocked = false;
    }
    oldBase = navState.base;
  }
  //# If we already have the same base state then we can replace that state
  if (oldBase === newBase) {
    if (oldMod === "none") {
      navReplace(newBase, "none", context);
      updateAppWithNavState(navState);
      return;
    }
    try {
      //# If we have some modifier on, then we need to go back one and replace that state
      navigationLocked = true;
      await navigateBack(1);
      navReplace(newBase, "none", context);
    } finally {
      navigationLocked = false;
    }
    updateAppWithNavState(navState);
    return;
  }
  //# When oldBase != newBase
  if (oldMod === "none") {
    navigateTo(newBase, oldMod, context);
    updateAppWithNavState(navState);
    return;
  }
  //# If we have some modifier on, then we need to replace the current state
  navReplace(newBase, "none", context);
  updateAppWithNavState(navState);
};

export var toBaseAt = async function(newBase, context, depth) {
  var backSteps, oldBase, oldDepth, oldMod;
  if (navigationLocked) {
    return;
  }
  oldBase = navState.base;
  oldMod = navState.modifier;
  oldDepth = navState.depth;
  if (typeof newBase !== "string") {
    throw new Error("In navhandler.toBase `newBase` must a string!");
  }
  if (typeof depth !== "number") {
    throw new Error("Depth must be specified, and be a number!");
  }
  if (depth === 0) {
    throw new Error("Depth cannot be 0!");
  }
  if (depth > oldDepth) {
    throw new Error("Our current depth is before the the newly specified depth. We don't dare to jump unto the unknown future!");
  }
  //# To cancel all future history we go back 1 step before the specified depth
  //# then we navigate into the desired state.
  backSteps = oldDepth - depth + 1;
  try {
    navigationLocked = true;
    await navigateBack(backSteps);
    navigateTo(newBase, "none", context);
  } finally {
    navigationLocked = false;
  }
  updateAppWithNavState(navState);
};

//###########################################################
export var toRoot = async function(clear) {
  if (navigationLocked) {
    return;
  }
  try {
    navigationLocked = true;
    if ((clear != null) && clear) {
      await clearNavTree();
    } else {
      await navigateBack(navState.depth);
    }
  } finally {
    navigationLocked = false;
  }
  updateAppWithNavState(navState);
};

export var back = async function(steps) {
  if (navigationLocked) {
    return;
  }
  try {
    navigationLocked = true;
    if (steps == null) {
      await navigateBack(1);
    } else if (typeof steps !== "number") {
      throw new Error("In navhandler.back `steps` is not a number!");
    } else {
      await navigateBack(steps);
    }
  } finally {
    navigationLocked = false;
  }
  updateAppWithNavState(navState);
};


//endregion
